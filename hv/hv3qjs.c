/*
 * hv3qjs.c --
 *
 *     Port of hv3see.c from SEE (Simple EcmaScript Engine)
 *     to QuickJS (https://bellard.org/quickjs/).
 *
 *     This file provides the C interface glue between Tcl and QuickJS,
 *     similar to what hv3see.c did for SEE.
 *
 *     NOTE: QuickJS and SEE are very different at the API level.
 */

/*-------------------------------------------------------------------------- 
 *                         Interpreter Interface
 *
 * ::qjs::interp
 *     Create a new QJS interpreter and return it's name (which may then be used as a Tcl command). Interpreter command names are always generated by this code, they can be renamed if required. 
 *
 * $interp destroy
 *     Delete an interpreter and all associated resources. The command $interp is deleted by this command.
 *
 * $interp global TCL-OBJECT
 *     Install the javascript wrapper of TCL-OBJECT as the global interpreter object. In web-browsers this is the Window object.
 *
 * $interp eval ?-file FILENAME? JAVASCRIPT
 *     Evaluate the supplied javascript using SEE_Global_eval().
 *
 *
 * $interp debug objects/alloc
 *     Return a list of Tcl commands this interpreter is holding as persistent-state objects.
 */

/*-------------------------------------------------------------------------- 
 *                      Tcl-based Javascript Objects
 *
 * As well as running javascript code, the Tcl application must provide implementations of DOM objects to the javascript interpreter. Objects are provided by one of two methods:
 *
 *     1) Explicitly, by calling the [$interp global] command.
 *     2) By returning a tcl-command like {object Tcl-COMMAND} or {transient Tcl-COMMAND} from an already existing Tcl-JS object (see below).
 *
 * In either case, the Tcl application provides the interpreter with a command that supports the following interface:
 *
 *        Call) $command THIS ?ARG-VALUE...?  (For functions only)
 *        Get)  $command PROPERTY
 *        Set)  $command PROPERTY ARG-VALUE
 *
 * Argument PROPERTY is a simple property name (i.e. "className"). VALUE is a typed javascript value. 
 *
 * Object resource management:
 *
 *     There are no resource management issues on the global object. The script must ensure that the specified command exists for the lifetime of the interpreter.
 *     For all other objects, once the object is passed to javascript, javascript is in charge of deleting the object.
 *
 *     An object is created by returning a command in one of the following two forms from a command already registered as a JS object.
 *
 *         {object    Tcl-COMMAND}
 *         {transient Tcl-COMMAND}
 *
 *     Both forms create the same kinds of javascript object, but the first initialises the object in "persistent" state the second in "transient" state. 
 *     Objects in "transient" state are eligible for garbage collection once the SEE interpreter state contains no more references to it. Objects in "persistent" state are not garbage collected until the interpreter is deleted.
 */
 
#include <tcl.h>
#include <quickjs.h>
#include <quickjs-atom.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

/* File hv3format.c contains the code to uniformly indent javascript text.
 * This is used to make stuff in the debugger more readable, it is not essential (and adds a fair overhead too).
 */
#include "hv3format.c"
#define ALLOW_EVENTS 1

typedef struct QjsTimeout QjsTimeout;
typedef struct QjsJsObject QjsJsObject;

typedef struct NodeHack NodeHack;
struct NodeHack {
	JSValue *pNodeObj;
	NodeHack *pParent;	/* Parent of this node */
	int iNode;			/* Node index */
};

typedef struct EventType EventType;

typedef struct ContextOpaque {
    Tcl_Interp *interp;
	Tcl_Obj *pLog;
    int iNextTimeout;  /* Start of a linked list of QjsTimeout structures. See included file hv3timeout.c for details. */
    QjsTimeout *pTimeout;  /* Used by the timer sub-system (hv3timeout.c). */
} ContextOpaque;

/* Structure representing an interpreter instance */
typedef struct QjsInterp {
	ContextOpaque;
    JSRuntime *rt;
    JSContext *ctx;
	ClientData instrumentData;
    JSValue eventPrototype;  /* Objects used by the events subsystem. See hv3events.c for details */
	Tcl_HashTable objects;  /* Hash table containing the objects created by the Tcl interpreter that are currently in "persistent" state. */
    /* Linked list of SeeJsObject structures that will be removed from the aJsObject[] table next time removeTransientRefs() is called.
     * Variable iNextJsObject is used to assign unique integer ids (SeeJsObject.iKey) to SeeJsObject instances as they are created. */
	uint16_t iKeyNext;
    QjsJsObject *pJsObject;
	JSValue global;
    // TODO: Store global object wrappers, timer/event state, etc.
} QjsInterp;
static unsigned int numQjsInterp = 0;
static unsigned int numFreeInterp = 0;

/* Each javascript object created by the Tcl-side is represented by an instance of the following struct. */
typedef struct QjsTclObject {
	Tcl_Obj *pObj;     // Tcl script for object
    Tcl_Obj **apWord;  // Array of Tcl_Obj pointers
    unsigned int nWord;       // Number of objects in array
    unsigned int nAllocWord;  // Allocated capacity
    EventType *pTypeList;  /* Used by the events sub-system (hv3events.c) */
	NodeHack *nodehandle;  /* Non-zero if this is a "node" object */
    /* This is used by objects while they reside in the QjsInterp.objects hash table. */
	Tcl_HashEntry *pEntry;
} QjsTclObject;
static unsigned int numQjsTclObject = 0;

typedef struct {JSValue v;} JSValueEntry;  // Structure for hash table entries

/* Entries in the SeeInterp.pJsObject[] linked list are instances of the following structure. */
struct QjsJsObject {
    int iKey;
    JSValue object;
    QjsJsObject *pNext;  /* Next entry in the SeeInterp.pJsObject list */
};

static Tcl_ObjCmdProc eventDispatchCmd;
static Tcl_ObjCmdProc eventDumpCmd;
static void eventTargetInit(QjsInterp*, JSValue);
static void freeEventTargetData(JSRuntime*, QjsTclObject*);
static void eventInit(JSContext*);

static JSClassID QjsTclClassId, QjsTclCallClassId;
static void getExoticObj(JSRuntime*);

/* Source file hv3timeout.c contains the implementation of the 
** following methods of the Window (global) object:
**
**     setTimeout()
**     setInterval()
**     clearTimeout()
**     clearInterval()
**
** The hv3timeout.c module uses the SeeInterp.pTimeout pointer. The
** external interface (called from this file) is:
*/ 
static void interpTimeoutInit(JSContext *);
static void interpTimeoutCleanup(QjsInterp *);
#include "hv3timeout.c"

static int allocWordArray(QjsInterp *qjs, QjsTclObject *w, int nExtra)
{
    if ((!w->nWord) || ((w->nAllocWord - w->nWord) < nExtra))
    {
        int n, rc;
        Tcl_Obj **ap;
        rc = Tcl_ListObjGetElements(qjs->interp, w->pObj, &n, &ap);
        if (rc != TCL_OK) return rc;

        w->nWord = n;
        w->nAllocWord = n + nExtra;
        w->apWord = js_malloc(qjs->ctx, sizeof(Tcl_Obj*) * w->nAllocWord);
        memcpy(w->apWord, ap, n*sizeof(Tcl_Obj*));
    }
    return TCL_OK;
}

static inline Tcl_Interp *getInterp(JSContext *ctx) {
	return ((ContextOpaque*)JS_GetContextOpaque(ctx))->interp;
}
/* Helper function to validate a JavaScript identifier */
static int isValidJSIdentifier(const char *str) {
    if (!str || !*str && !isalpha(*str) && *str != '_' && *str != '$') return 0;
    for (const char *p = str + 1; *p; p++) {
        if (!isalnum(*p) && *p != '_' && *p != '$') return 0;
    }
    return 1;
}

/*
 *---------------------------------------------------------------------------
 *
 * stringToObj --
 *
 *     Create a Tcl object containing a copy of the JSValue str. The returned object has a ref-count of 0.
 *
 * Results:
 *
 * Side effects:
 *
 *---------------------------------------------------------------------------
 */
static inline Tcl_Obj *stringToObj(JSContext *ctx, JSValue str){
	size_t l;
	const char *s = JS_ToCStringLen(ctx, &l, str);
	Tcl_Obj *p = Tcl_NewStringObj(s, l);
	JS_FreeCString(ctx, s);
	return p;
}

/* Utility: Convert QuickJS JSValue to a Tcl_Obj* */
static Tcl_Obj *qjsValueToTcl(JSContext *ctx, JSValue val) {
    Tcl_Obj *result;
    if (JS_IsNull(val) || JS_IsUndefined(val)) {
        result = Tcl_NewObj();  // In Tcl, the closest equivalent to null is typically an empty string
    } else if (JS_IsBool(val)) {
        result = Tcl_NewBooleanObj(JS_ToBool(ctx, val));
    } else if (JS_IsNumber(val)) {
		if (JS_VALUE_GET_TAG(val) == JS_TAG_INT) {
			int i;
			JS_ToInt32(ctx, &i, val);
			result = Tcl_NewIntObj(i);
		} else {
			double d;
			JS_ToFloat64(ctx, &d, val);
			result = Tcl_NewDoubleObj(d);
		}
    } else if (JS_IsString(val)) {
		result = stringToObj(ctx, val);
    } else if (JS_IsObject(val)) {
		if (JS_IsArray(ctx, val)) {
			uint32_t i, len;
			JS_ToUint32(ctx, &len, JS_GetPropertyStr(ctx, val, "length"));  // Get array length
			result = Tcl_NewListObj(len, NULL);
			for (i = 0; i < len; i++) {  // Iterate through each element
				JSValue e = JS_GetPropertyUint32(ctx, val, i);
				Tcl_ListObjAppendElement(NULL, result, qjsValueToTcl(ctx, e));
			}
		} else {  // Errors are handled here
	        // For objects/functions, may want to wrap/bridge them
			JSClassID id = JS_GetClassID(val);
			if (id == QjsTclClassId || id == QjsTclCallClassId) {
				result = ((QjsTclObject*)JS_GetOpaque(val, id))->pObj;
			} else {
				result = stringToObj(ctx, val);
			}
		}
    } else if (JS_IsException(val)) {
		JSValue exc = JS_GetException(ctx);
		result = stringToObj(ctx, exc);
		JS_FreeValue(ctx, exc);
	} else {
        result = Tcl_ObjPrintf("[TCL-JS UNKNOWN %d]", JS_VALUE_GET_TAG(val));
    }
    JS_FreeValue(ctx, val);
    return result;
}

static inline Tcl_Obj *
argValueToTcl(QjsInterp *qjs, JSValueConst val, int *pN) {
	if (JS_IsBool(val) || JS_IsString(val)) return stringToObj(qjs->ctx, val);
	if (JS_IsObject(val)) {
		JSClassID id;
        Tcl_Obj *aTclValues[2];
		aTclValues[0] = Tcl_NewStringObj("object", 6);
        QjsTclObject *pO = JS_GetAnyOpaque(val, &id);
		if (pO && id == QjsTclClassId || id == QjsTclCallClassId) {
			aTclValues[1] = pO->pObj;
		} else {
			/* Create the new QjsJsObject structure. */
			QjsJsObject *pJsObject = js_malloc(qjs->ctx, sizeof(QjsJsObject));
			pJsObject->iKey = qjs->iKeyNext++;
			pJsObject->object = val;

			pJsObject->pNext = qjs->pJsObject;
			qjs->pJsObject = pJsObject;

			aTclValues[1] = Tcl_NewIntObj(pJsObject->iKey);
			(*pN)++;
		}
        return Tcl_NewListObj(2, aTclValues);
	} 
	return qjsValueToTcl(qjs->ctx, JS_DupValue(qjs->ctx, val));
}

static void removeTransientRefs(QjsInterp *qjs, int n)
{
    while (n-- && qjs->pJsObject) {
		QjsJsObject *pJsObject = qjs->pJsObject;
        qjs->pJsObject = qjs->pJsObject->pNext;
		js_free(qjs->ctx, pJsObject);
    }
}

static int evalObjv(Tcl_Interp *interp, int nWord, Tcl_Obj **apWord){
#if 1
	printf("%d. ", nWord);
    for (int i=0; i<nWord;) printf("%d: %s. ", i++, Tcl_GetString(apWord[i]));
    printf("\n");
#endif
    return Tcl_EvalObjv(interp, nWord, apWord, TCL_EVAL_GLOBAL);
}

/*
 *---------------------------------------------------------------------------
 *
 * callQjsTclMethod --
 *
 *     This is a helper function used to call the following methods of
 *     the supplied SeeTclObject (argument p):
 *
 *         Get Put CanPut HasProperty Delete DefaultValue Enumerator
 *
 *     The other methods (Call and Construct) are invoked via
 *     tclCallOrConstruct().
 *
 * Results: 
 *     See above.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static int callQjsTclMethod(
    Tcl_Interp *interp,         /* Tcl Interpreter context */
    Tcl_Obj *pLog,              /* Log command */
    JSValueConst obj,           /* Object to call method of */
    Tcl_Obj *pProp,             /* First argument (or null) */
    Tcl_Obj *pVal)              /* Second argument (or null) */
{
    int rc, nArg = 1;
	QjsTclObject *p = JS_GetOpaque(obj, JS_GetClassID(obj));

    assert(p->nAllocWord - p->nWord >= 3);

	p->apWord[p->nWord] = pProp;

    if (pVal) {
        p->apWord[p->nWord+nArg] = pVal;
        nArg++;
    }

    rc = evalObjv(interp, p->nWord+nArg, p->apWord);
	
    if (pLog && rc==TCL_OK) {
        Tcl_Obj *pEval = Tcl_DuplicateObj(pLog);
        Tcl_Obj *pRes = Tcl_GetObjResult(interp);
        Tcl_IncrRefCount(pRes);

        Tcl_ListObjAppendElement(0, pEval, Tcl_NewStringObj("ECMASCRIPT", 10));
        Tcl_ListObjAppendElement(0, pEval, p->pObj);
        if (pProp) Tcl_ListObjAppendElement(0, pEval, pProp);
        if (pVal) Tcl_ListObjAppendElement(0, pEval, pVal);
        Tcl_ListObjAppendElement(0, pEval, pRes);
        Tcl_EvalObjEx(interp, pEval, TCL_EVAL_DIRECT|TCL_EVAL_GLOBAL);

        Tcl_SetObjResult(interp, pRes);
        Tcl_DecrRefCount(pRes);
    }
	
    return rc;
}

/*
 *---------------------------------------------------------------------------
 *
 * newSeeTclObject --
 *
 *     Allocate and return a pointer to a new SeeTclObject structure 
 *     based on the Tcl command passed as the second argument.
 *
 * Results:
 *     Pointer to new SeeTclObject structure.
 *
 * Side effects:
 *     None.
 *
 *---------------------------------------------------------------------------
 */
static JSValue newQjsTclObject(QjsInterp *qjs, JSClassID id, Tcl_Obj *pTclCmd, QjsTclObject **p)
{
    QjsTclObject *qjsTclObj;

    JSValue obj = JS_NewObjectClass(qjs->ctx, id);
//	printf("%p #%d\n", JS_VALUE_GET_PTR(obj), numQjsTclObject);
    if (JS_IsException(obj)) return obj;
	
    qjsTclObj = js_mallocz(qjs->ctx, sizeof(*qjsTclObj));
    if (!qjsTclObj) goto error;
	qjsTclObj->pObj = pTclCmd;
    JS_SetOpaque(obj, qjsTclObj);
	
	Tcl_IncrRefCount(qjsTclObj->pObj);
    if (allocWordArray(qjs, qjsTclObj, 4) != TCL_OK) {
		Tcl_DecrRefCount(qjsTclObj->pObj);
        goto error;
	}
    numQjsTclObject++;
	if (p != NULL) *p = qjsTclObj;
    return obj;
	error:
		js_free(qjs->ctx, qjsTclObj);
		JS_FreeValue(qjs->ctx, obj);
		return JS_EXCEPTION;
}

static void finalizeObject(JSRuntime *rt, JSValue val)
{
    QjsTclObject *qjsTclObj = JS_GetOpaque(val, JS_GetClassID(val));
    if (qjsTclObj) {  // Decrement reference count for each Tcl object
        for (int i = 0; i < qjsTclObj->nWord; i++) {
            Tcl_DecrRefCount(qjsTclObj->apWord[i]);
        }
        // Free the array and qjsTclObj
        js_free_rt(rt, qjsTclObj->apWord);
		assert(qjsTclObj->pObj->refCount >= 1);
	//	Tcl_DecrRefCount(qjsTclObj->pObj);
		if (qjsTclObj->pEntry) {
			JSValueEntry *pV = (JSValueEntry*)Tcl_GetHashValue(qjsTclObj->pEntry);
			Tcl_DeleteHashEntry(qjsTclObj->pEntry);
			qjsTclObj->pEntry = NULL;
			ckfree(pV);
		}
	#if ALLOW_EVENTS
		freeEventTargetData(rt, qjsTclObj);
	#endif
        js_free_rt(rt, qjsTclObj);
    }
//	printf("-%p\n", JS_VALUE_GET_PTR(val));
	numQjsTclObject--;
}

static JSValue createTransient(QjsInterp *qjs, Tcl_Obj *pTclCmd)
{
	JSValue func_obj = newQjsTclObject(qjs, QjsTclCallClassId, pTclCmd, 0);
	JS_SetConstructorBit(qjs->ctx, func_obj, 1);
    return func_obj;
}

/*
 *---------------------------------------------------------------------------
 *
 * findOrCreateObject --
 *
 * Results:
 *     Returns a JSValue representing an object, duplicated for the caller.
 *
 * Side effects:
 *     May create a new JSValueEntry structure and add it to the qjs->objects hash table.
 *     Initializes the event subsystem for new objects.
 *
 *---------------------------------------------------------------------------
 */
static JSValue findOrCreateObject(QjsInterp *qjs, Tcl_Obj *pTclCmd)
{
    Tcl_Interp *interp = qjs->interp;
    const char *zCmd = Tcl_GetString(pTclCmd);
    JSValueEntry *pObject;
    Tcl_HashEntry *pEntry;
	int isNew;
	
    /* See if this is a javascript object reference. It is assumed to
     * be a javascript reference if the first character is a digit.
     */
    if (isdigit(zCmd[0])){
        if (TCL_OK != Tcl_GetIntFromObj(interp, pTclCmd, &isNew)) return JS_EXCEPTION;
	    QjsJsObject *pJsObject;
		for (
			pJsObject = qjs->pJsObject;
			pJsObject && pJsObject->iKey != isNew;
			pJsObject = pJsObject->pNext
		);
		if (!pJsObject) return JS_EXCEPTION;
		return pJsObject->object;
    }

    /* Search for an existing Tcl object */
    pEntry = Tcl_CreateHashEntry(&qjs->objects, zCmd, &isNew);

    if (isNew) {
        /* No existing entry, create a new one */
		QjsTclObject *p;
        /* Create new JSValueEntry */
        pObject = ckalloc(sizeof(*pObject));
        /* Create new object and store it */
        pObject->v = newQjsTclObject(qjs, QjsTclClassId, pTclCmd, &p);
        /* Store in hash table */
        Tcl_SetHashValue(pEntry, pObject);
		p->pEntry = pEntry;

        /* Initialize the object's event subsystem */
	#if ALLOW_EVENTS
        eventTargetInit(qjs, pObject->v);
	#endif
    }
    /* Existing entry found */
    pObject = (JSValueEntry *)Tcl_GetHashValue(pEntry);

    /* Return a duplicated JSValue for the caller */
    return JS_DupValue(qjs->ctx, pObject->v);
}

static JSValue createNode(QjsInterp *qjs, Tcl_Obj *pTclCmd)
{
    JSValue obj = findOrCreateObject(qjs, pTclCmd);
	assert(JS_VALUE_HAS_REF_COUNT(obj));
	QjsTclObject *p = JS_GetOpaque(obj, QjsTclClassId);
    if (p->nodehandle == 0) {
        Tcl_Command t;
        Tcl_CmdInfo info;
        t = Tcl_GetCommandFromObj(qjs->interp, p->apWord[2]);
        assert(t);
        Tcl_GetCommandInfoFromToken(t, &info);
        p->nodehandle = info.objClientData;
        ((NodeHack *)p->nodehandle)->pNodeObj = JS_VALUE_GET_PTR(obj);
    }
    return obj;
}

static JSValue createBridge(QjsInterp *qjs, Tcl_Obj *pTclCmd)
{
    Tcl_Command t;
    Tcl_CmdInfo info;
    QjsInterp *foreignQjs;

    t = Tcl_GetCommandFromObj(qjs->interp, pTclCmd);
    if(!t) return JS_NULL;
    Tcl_GetCommandInfoFromToken(t, &info);
    foreignQjs = info.objClientData;
	JSValue global = JS_GetGlobalObject(foreignQjs->ctx);
    assert(JS_GetClassID(global) == QjsTclClassId);
    return global;
}

/* Utility: Convert Tcl_Obj* to QuickJS JSValue */
static JSValue objToValue(JSContext *ctx, Tcl_Obj *pObj) {
    // This is a stub: may want to parse Tcl lists to JS objects, etc.
    double d;
    int n;
    if (Tcl_GetDoubleFromObj(NULL, pObj, &d) == TCL_OK) {
        return JS_NewFloat64(ctx, d);
    } else if (Tcl_GetIntFromObj(NULL, pObj, &n) == TCL_OK) {
        return JS_NewInt32(ctx, n);
    } else if (Tcl_GetBooleanFromObj(NULL, pObj, &n) == TCL_OK) {
        return JS_NewBool(ctx, n);
    } else {  // Fallback: treat as string
		if (pObj->typePtr == Tcl_GetObjType("list")) {
			Tcl_Obj **ap;
			QjsInterp *qjs = (QjsInterp*)JS_GetContextOpaque(ctx);
			Tcl_ListObjGetElements(qjs->interp, pObj, &n, &ap);
			if (n == 1) return objToValue(ctx, ap[0]);
			if (n == 2) {
				static const char *const aType[] = {"object", "node", "method", "bridge", "transient", NULL};
				Tcl_GetIndexFromObj(qjs->interp, ap[0], aType, "type", TCL_EXACT, &n);
				switch (n) {
					case 0: return findOrCreateObject(qjs, ap[1]); // Object
					case 1: return createNode(qjs, ap[1]); 	      // Node
					case 2: return createTransient(qjs, ap[1]);  // Method
					case 3: return createBridge(qjs, ap[1]);    // Another context's global object
					case 4: return newQjsTclObject(qjs, QjsTclClassId, ap[1], NULL);
				}
			}
		}
		const char *s = Tcl_GetStringFromObj(pObj, &n);
		if (!n || n==9 && !strcmp(s, "undefined")) return JS_UNDEFINED;
		if (n==4 && !strcmp(s, "null")) return JS_NULL;
        return JS_NewStringLen(ctx, s, n);
    }
}

JSValue throwTclError(JSContext *ctx, Tcl_Interp* interp) {
    JSValue err = JS_NewError(ctx);
    JSValue str = JS_NewString(ctx, Tcl_GetStringResult(interp));
    JS_SetPropertyStr(ctx, err, "message", str);
    return JS_Throw(ctx, err);
}

static JSValue createNative(QjsInterp *qjs, Tcl_Obj *pTclList)
{
    unsigned int n, i, rc;
    Tcl_Obj **ap;

    rc = Tcl_ListObjGetElements(qjs->interp, pTclList, &n, &ap);
    if (rc != TCL_OK) return throwTclError(qjs->ctx, qjs->interp);

    JSValue ret = JS_NewObject(qjs->ctx);
    for (i = 0; i < (n-1); i += 2){
		JS_SetPropertyStr(qjs->ctx, ret, Tcl_GetString(ap[i]), objToValue(qjs->ctx, ap[i+1]));
    }
    return ret;
}

/*
 *---------------------------------------------------------------------------
 *
 * handleJavascriptError --
 *
 *     This function is designed to be called when a javascript error occurs.
 *
 * Results:
 *     Always returns TCL_ERROR.
 *
 * Side effects:
 *     Sets the result of Tcl interpreter qjs->interp.
 *
 *---------------------------------------------------------------------------
 */
static int handleJavascriptError(QjsInterp *qjs, JSValue val) {
   /* The Tcl error message is a well formed Tcl list. The elements
    * of which are as follows:
    *
    *   * The literal string "JS_ERROR"
    *   * The string form of the javascript object thrown.
    *   * The value of $errorInfo (if this is a Tcl error, otherwise 
    *     an empty string).
    *   * Followed by an even number of elements - alternating filenames
    *     and line numbers that make up the stack trace (first pair
    *     is at the bottom of the stack - where the exception was thrown
    *     from).
    */
    Tcl_Obj *pError = Tcl_NewObj();
    Tcl_ListObjAppendElement(0, pError, Tcl_NewStringObj("JS_ERROR", 8));
    /* If there is a Tcl error, append it. Otherwise append an empty string. */
    if (JS_IsException(val)) {
        JSValue exc = JS_GetException(qjs->ctx);
		Tcl_ListObjAppendElement(0, pError, stringToObj(qjs->ctx, exc));
		JS_FreeValue(qjs->ctx, exc);
    } else {
        Tcl_ListObjAppendElement(0, pError, Tcl_NewStringObj("", 0));
    }
    Tcl_SetObjResult(qjs->interp, pError);
    return TCL_ERROR;
}

/*
 *---------------------------------------------------------------------------
 *
 * delInterpCmd --
 *
 *     This function is called when a SeeInterp is deleted.
 *     Tcl command: $interp destroy 
 *
 * Results:
 *     None.
 *
 * Side effects:
 *
 *---------------------------------------------------------------------------
 */
static void delInterpCmd(ClientData cd) {
    QjsInterp *qjs = (QjsInterp*)cd;
    if (qjs) {
		if (qjs->pLog) {
			Tcl_DecrRefCount(qjs->pLog);
			qjs->pLog = 0;
		}
		
		Tcl_HashSearch search;
		Tcl_HashEntry* pEntry = Tcl_FirstHashEntry(&qjs->objects, &search);
		while (pEntry) {
			JSValueEntry *pO = (JSValueEntry*)Tcl_GetHashValue(pEntry);
			pEntry = Tcl_NextHashEntry(&search);
            // Set pEntry to NULL in the associated QjsTclObject to prevent finalizeObject from deleting it
            ((QjsTclObject*)JS_GetOpaque(pO->v, QjsTclClassId))->pEntry = NULL;
            JS_FreeValue(qjs->ctx, pO->v); // Decrement refcount, may trigger finalizeObject
            ckfree(pO); // Free the JSValueEntry
		}
		Tcl_DeleteHashTable(&qjs->objects);

		interpTimeoutCleanup(qjs);
		
        JS_FreeContext(qjs->ctx);
		JSRuntime *rt = qjs->rt;
        js_free_rt(rt, qjs);
		
        if (numQjsInterp-numFreeInterp < 2) JS_FreeRuntime(rt);
    } // The command is deleted by Tcl automatically
	numFreeInterp++;
}

typedef struct {
  const char *zName;
  int isBoolean;
  Tcl_Obj *pVal;
} TclCmdArg;

static int
processArgs(Tcl_Interp *interp, TclCmdArg *aOpt, int objc, Tcl_Obj *const objv[])
{
    for (int i = 0; i < objc; i++){
        Tcl_Obj *p = objv[i];
        size_t s = sizeof(TclCmdArg);
        int idx;
        if (Tcl_GetIndexFromObjStruct(interp, p, aOpt, s, "option", 0, &idx)) {
            return TCL_ERROR;
        }
        if (0 == aOpt[idx].isBoolean) {
            i++;
            if (i >= objc) {
                Tcl_AppendResult(interp, "option ", aOpt[idx].zName, " requires an argument", 0);
                return TCL_ERROR;
            }
        }
        aOpt[idx].pVal = objv[i];
    }
    return TCL_OK;
}

/*
 *---------------------------------------------------------------------------
 *
 * interpEval --
 *
 *     This function does the work of the [$qjs_interp eval JAVASCRIPT]
 *     Tcl command. Syntax:
 *
 *         $interp eval ?OPTIONS? JAVASCRIPT
 *
 *     where OPTIONS are:
 *
 *         -file  FILENAME
 *         -scope JAVASCRIPT-OBJECT
 *
 * Results:
 *     Tcl result - TCL_OK or TCL_ERROR.
 *
 * Side effects:
 *     Executes the block of javascript passed as parameter pCode in
 *     the global context.
 *
 *---------------------------------------------------------------------------
 */
static int interpEval(QjsInterp *qjs, int objc, Tcl_Obj *const objv[])
{
	Tcl_Interp *interp = qjs->interp;
	int rc = TCL_OK;
    TclCmdArg aOptions[] = {
        {"-file",     0, 0},
        {"-noresult", 1, 0},
        {0, 0, 0}
    };
	const char *file; /* Value passed to -file option */
    int noR;          /* True if -noresult */
	int l;            /* Length of script */

    if (processArgs(interp, aOptions, objc-3, &objv[2])) return TCL_ERROR;

    const char *code = Tcl_GetStringFromObj(objv[objc-1], &l); /* Javascript to evaluate */
    noR = aOptions[1].pVal != 0;

	file = aOptions[0].pVal ? Tcl_GetString(aOptions[0].pVal) : "<eval>";
    JSValue result = JS_Eval(qjs->ctx, code, l, file, JS_EVAL_TYPE_GLOBAL);

    if (JS_IsException(result)) {
        rc = handleJavascriptError(qjs, result);
	} else if (!noR) {
        Tcl_SetObjResult(interp, qjsValueToTcl(qjs->ctx, JS_DupValue(qjs->ctx, result)));
    }
	JS_FreeValue(qjs->ctx, result);
    return rc;
}

static JSValue 
tclLambda(JSContext *ctx, JSValueConst this, int argc, JSValueConst *argv, int m, JSValue *o)
{
	int i, rc;
	Tcl_Interp *interp = getInterp(ctx);
	if (!interp) return JS_ThrowTypeError(ctx, "Tcl interpreter not available");

	Tcl_Obj *pCmd = Tcl_NewStringObj("apply", 5);
    rc = Tcl_ListObjAppendElement(interp, pCmd, stringToObj(ctx, o[0]));
	if(rc!=TCL_OK) JS_ThrowTypeError(ctx, "could not append lambda");

	for (i = 0; i < argc; i++) {
        rc = Tcl_ListObjAppendElement(interp, pCmd, qjsValueToTcl(ctx, JS_DupValue(ctx, argv[i])));
		if(rc!=TCL_OK) JS_ThrowTypeError(ctx, "could not append arguments");
    }
	rc = Tcl_EvalObjEx(interp, pCmd, 0);
	if (rc != TCL_OK) return throwTclError(ctx, interp);
	return objToValue(ctx, Tcl_GetObjResult(interp));
}

static int interpFunction(QjsInterp *qjs, int objc, Tcl_Obj *const objv[])
{	
	const char *name = Tcl_GetString(objv[2]);
	if (!isValidJSIdentifier(name)) { /* Validate function name */
        Tcl_SetObjResult(qjs->interp, Tcl_ObjPrintf("Invalid function name: %s", name));
        return TCL_ERROR;
    }  // Add arguments and body
	JSValue o[1];
	o[0] = JS_NewString(qjs->ctx, Tcl_GetString(Tcl_NewListObj(2, &objv[3])));
	JSValue glb = JS_GetGlobalObject(qjs->ctx);
    JS_SetPropertyStr(qjs->ctx, glb, name, JS_NewCFunctionData(qjs->ctx, tclLambda, 1, 0, 1, o));
	JS_FreeValue(qjs->ctx, o[0]);
	JS_FreeValue(qjs->ctx, glb);
	return TCL_OK;
}

static int interpCall(QjsInterp *qjs, int objc, Tcl_Obj *const objv[])
{
	int i, n;     // Number of arguments
	Tcl_Obj **p;  // Individual arguments as Tcl objects
	
	const char *name = Tcl_GetString(objv[2]);
	if (Tcl_ListObjGetElements(qjs->interp, objv[3], &n, &p) != TCL_OK) { // Get arguments
		return TCL_ERROR;
	}
	JSValue args[n];
	for (i=0; i < n; i++) args[i] = objToValue(qjs->ctx, p[i]);
	
	JSValue glb = JS_GetGlobalObject(qjs->ctx);
	JSValue function = JS_GetPropertyStr(qjs->ctx, glb, name);
	JS_FreeValue(qjs->ctx, glb);
	
	/*if (!JS_IsFunction(qjs->ctx, function)) { // JS_Call can tell if is a function already
		Tcl_AppendResult(qjs->interp, "Function does not exist: ", name, 0);
		return TCL_ERROR;
	}*/
	JSValue result = JS_Call(qjs->ctx, function, function, n, args);
	for (i=0; i < n; i++) JS_FreeValue(qjs->ctx, args[i]);
	JS_FreeValue(qjs->ctx, function);
	Tcl_SetObjResult(qjs->interp, qjsValueToTcl(qjs->ctx, result));
	JS_FreeValue(qjs->ctx, result);

	return TCL_OK;
}

static int interpProc(QjsInterp *qjs, int objc, Tcl_Obj *const objv[])
{
	int l, i, argc;
	Tcl_Obj **args, *pCode;
    const char *code, *funcName = Tcl_GetString(objv[2]);

    if (!isValidJSIdentifier(funcName)) { /* Validate function name */
        Tcl_SetResult(qjs->interp, "Invalid function name", TCL_STATIC);
        return TCL_ERROR;
    }
	/* Process comma-separated arguments */
    if (Tcl_ListObjGetElements(qjs->interp, objv[3], &argc, &args)!=TCL_OK) {
        return TCL_ERROR;
    }
	pCode = Tcl_ObjPrintf("function %s (", funcName);
    for (i = 0; i < argc; i++) {  /* Validate each argument as a JavaScript identifier */
        if (!isValidJSIdentifier(Tcl_GetString(args[i]))) {
            Tcl_SetResult(qjs->interp, "Invalid argument name", TCL_STATIC);
            return TCL_ERROR;
        }
		if (i > 0) Tcl_AppendToObj(pCode, ", ", 2);  /* Join arguments with commas */
        Tcl_AppendObjToObj(pCode, args[i]);
    }
	Tcl_AppendToObj(pCode, ")", 1);
	Tcl_ListObjAppendElement(qjs->interp, pCode, objv[4]);
	
	code = Tcl_GetStringFromObj(pCode, &l); /* Javascript to evaluate */
	JSValue result = JS_Eval(qjs->ctx, code, l, "<proc>", JS_EVAL_TYPE_GLOBAL);

	if (JS_IsException(result)) return handleJavascriptError(qjs, result);
	JS_FreeValue(qjs->ctx, result);
	return TCL_OK;
}

static int interpGlobalSet(QjsInterp *qjs, Tcl_Obj *pProp, Tcl_Obj *pVal)
{
    JSValue glb = JS_GetGlobalObject(qjs->ctx);
	if (pProp == NULL) {
		QjsTclObject *w = JS_GetOpaque(glb, QjsTclClassId);
		Tcl_SetObjResult(qjs->interp, w->pObj);
	} else if (pVal == NULL) {
		JSValue prop = JS_GetPropertyStr(qjs->ctx, glb, Tcl_GetString(pProp));
		Tcl_SetObjResult(qjs->interp, qjsValueToTcl(qjs->ctx, prop));
	} else {
	    JS_SetPropertyStr(qjs->ctx, glb, Tcl_GetString(pProp), objToValue(qjs->ctx, pVal));
	}
	JS_FreeValue(qjs->ctx, glb);
    return TCL_OK;
}

/*
 *---------------------------------------------------------------------------
 *
 * interpDebug --
 *
 *    Implementation of the [$interp debug] command. This command is
 *    not required for normal operation, but provides some sub-commands
 *    useful while debugging the system.
 *    
 *       $interp debug objects
 *       $interp debug alloc
 *
 *    (Probably there are more sub-commands, peers of "objects", to come)
 *
 * Results:
 *
 * Side effects:
 *
 *---------------------------------------------------------------------------
 */
static int interpDebug(QjsInterp *qjs, int objc, Tcl_Obj *const objv[]) {
    TclCmdArg aOptions[] = {{"objects", 1, 0}, {"alloc", 1, 0}, {0, 0, 0}};
    if (processArgs(qjs->interp, aOptions, 1, &objv[2])) return TCL_ERROR;

    Tcl_Obj *pRet = Tcl_NewObj();
    if (aOptions[1].pVal) { // alloc subcommand
        JSMemoryUsage s;
        JS_ComputeMemoryUsage(qjs->rt, &s);
		
		const char *azNames[15] = {
			"QjsTclObject structures allocated", "memory allocated", "memory used", "atoms", "strings",
			"objects", "  properties", "  shapes", "bytecode functions", "  bytecode",
			"  pc2line", "C functions", "arrays", "  elements", "binary objects",
		};
		int counts[15] = {
			numQjsTclObject, s.malloc_count, s.memory_used_count, s.atom_count, s.str_count,
			s.obj_count, s.prop_count, s.shape_count, s.js_func_count, s.js_func_count,  /* bytecode uses func count */
			s.js_func_pc2line_count, s.c_func_count, s.array_count, s.fast_array_elements, s.binary_object_count,
		};
		int sizes[15] = {
			-1, s.malloc_size, s.memory_used_size, s.atom_size, s.str_size,
			s.obj_size, s.prop_size, s.shape_size, s.js_func_size, s.js_func_code_size,
			s.js_func_pc2line_size, -1, -1, s.fast_array_elements*sizeof(JSValue), s.binary_object_size,
		};
		for (int i = 0; i < 15; i++){
			Tcl_Obj *pRow = Tcl_NewObj();
			Tcl_ListObjAppendElement(NULL, pRet, Tcl_NewStringObj(azNames[i], -1));
			Tcl_ListObjAppendElement(NULL, pRow, Tcl_NewIntObj(counts[i]));
			if (sizes[i] > 0) {
				Tcl_ListObjAppendElement(NULL, pRow, Tcl_NewIntObj(sizes[i]));
				Tcl_ListObjAppendElement(NULL, pRow, Tcl_NewDoubleObj((double)sizes[i]/counts[i]));
			}
			Tcl_ListObjAppendElement(NULL, pRet, pRow);
        }
    } else if (aOptions[0].pVal) { // objects subcommand
		Tcl_HashSearch search;
		Tcl_HashEntry* pEntry;
		for (pEntry=Tcl_FirstHashEntry(&qjs->objects, &search); pEntry; pEntry=Tcl_NextHashEntry(&search)) {
			JSValueEntry *pObject = (JSValueEntry *)Tcl_GetHashValue(pEntry);
			Tcl_Obj *p = ((QjsTclObject*)JS_GetOpaque(pObject->v, QjsTclClassId))->pObj;
            Tcl_ListObjAppendElement(NULL, pRet, p);
		}
    }
    Tcl_SetObjResult(qjs->interp, pRet);
    return TCL_OK;
}

static int interpCmd(
    ClientData clientData,             /* The SeeInterp data structure */
    Tcl_Interp *interp,                /* Current interpreter. */
    int objc,                          /* Number of arguments. */
    Tcl_Obj *CONST objv[]              /* Argument strings. */
) {
    int rc = TCL_OK;
    QjsInterp *qjs = (QjsInterp *)clientData;
    int choice, nMin, nMax;

    enum INTERP_enum {
        INTERP_DESTROY,               /* Destroy the interpreter */
        INTERP_EVAL,                  /* Evaluate some javascript */
        INTERP_FUNC,
        INTERP_PROC,
        INTERP_CALL,
        INTERP_NODE,  // Used in hv3_dom.tcl line 300+
        INTERP_GLOBAL,
        INTERP_GC,
        INTERP_DISPATCH,              /* Dispatch a DOM event */
		/* Debugging API - not essential for normal operation. */
        INTERP_DEBUG,
        INTERP_LOG,
        INTERP_EVENTS,
    };
    static const struct InterpSubCommand {
        const char *zCommand;
        enum INTERP_enum eSymbol;
        uint8_t nMinArgs, nMaxArgs;
        char *zArgs;
    } aSubCommand[] = {
        {"destroy",  INTERP_DESTROY,  0, 0, ""},
        {"eval",     INTERP_EVAL,     0, 5, "?-file FILENAME? ?-noresult BOOL? JAVASCRIPT"},
        {"function", INTERP_FUNC,     3, 3, "NAME ARGUMENTS BODY"},
        {"proc",     INTERP_PROC,     3, 3, "NAME ARGUMENTS BODY"},
        {"call",     INTERP_CALL,     2, 2, "NAME ARGUMENTS"},
        {"node",     INTERP_NODE,     1, 1, "TCL-COMMAND"},
        {"global",   INTERP_GLOBAL,   0, 2, "?PROPERTY? ?JAVASCRIPT-VALUE?"},
        {"rungc",    INTERP_GC,       0, 0, ""},
        {"dispatch", INTERP_DISPATCH, 2, 2, "TARGET-COMMAND EVENT-COMMAND"},
		{"debug",    INTERP_DEBUG,    1, 1, "SUB-COMMAND"},
		{"log",      INTERP_LOG,      1, 1, "TCL-COMMAND"},
		{"events",   INTERP_EVENTS,   1, 1, "TCL-COMMAND"},
        {0, 0, 0, 0}
    };
    if (objc < 2) {
        Tcl_WrongNumArgs(interp, 1, objv, "SUBCOMMAND ...");
        return TCL_ERROR;
    }
    if (Tcl_GetIndexFromObjStruct(interp, objv[1], aSubCommand, sizeof(struct InterpSubCommand), "option", 0, &choice)){
        return TCL_ERROR;
    }
    nMin = aSubCommand[choice].nMinArgs;
    nMax = aSubCommand[choice].nMaxArgs;
    if (nMin >= 0 && objc < nMin+2 || nMax >= 0 && objc > nMax+2) {
        Tcl_WrongNumArgs(interp, 2, objv, aSubCommand[choice].zArgs);
        return TCL_ERROR;
    }
    switch (aSubCommand[choice].eSymbol) {
        case INTERP_EVAL: { // qjs eval ?OPTIONS? PROGRAM-TEXT
            rc = interpEval(qjs, objc, objv); // Evaluate a javascript script.
            break;
        }
		case INTERP_FUNC: {
            rc = interpFunction(qjs, objc, objv);
            break;
        }
		case INTERP_PROC: {
            rc = interpProc(qjs, objc, objv);
            break;
        }
		case INTERP_CALL: {
            rc = interpCall(qjs, objc, objv);
            break;
        }
        case INTERP_NODE: { // qjs node JAVASCRIPT-OBJECT
            createNode(qjs, objv[2]);
            break;
        }
        case INTERP_GLOBAL: { // qjs global PROPERTY JAVASCRIPT-VALUE
			rc = interpGlobalSet(qjs, objc>2?objv[2]:NULL, objc>3?objv[3]:NULL);
            break;
        }
		case INTERP_GC: {
			JS_RunGC(qjs->rt);
            break;
        }
        case INTERP_DISPATCH: { // $interp dispatch
		#if ALLOW_EVENTS
            rc = eventDispatchCmd(clientData, interp, objc, objv);
		#endif
			break;
        }
        case INTERP_DEBUG: { // interp debug SUB-COMMAND
            rc = interpDebug(qjs, objc, objv);
            break;
        }
        case INTERP_EVENTS: {
		#if ALLOW_EVENTS
            rc = eventDumpCmd(clientData, interp, objc, objv);
		#endif
			break;
        }
		case INTERP_LOG: {
            if (qjs->pLog) {
                Tcl_DecrRefCount(qjs->pLog);
                qjs->pLog = 0;
            }
            if (Tcl_GetCharLength(objv[2])) {
                qjs->pLog = objv[2];
                Tcl_IncrRefCount(qjs->pLog);
            }
            break;
        }
        case INTERP_DESTROY: { // qjs destroy
            /* Deleting the command automatically calls delInterpCmd() */
            Tcl_DeleteCommand(interp, Tcl_GetString(objv[0]));
            break;
        }
	}
    return rc;
}

/*
 *---------------------------------------------------------------------------
 *
 * tclQjsInterp --
 *
 *     Implementation of [::qjs::interp].
 *
 *     Creates a new javascript interpreter object-command.
 *
 * Results:
 *     TCL_OK or TCL_ERROR.
 *
 * Side effects:
 *     See above.
 *
 *---------------------------------------------------------------------------
 */
static int tclQjsInterp(ClientData cd, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[])
{
    char zCmd[64];
    QjsInterp *qjs;
    if (objc != 2) {
        Tcl_WrongNumArgs(interp, 1, objv, "GLOBAL-OBJCOMMAND");
        return TCL_ERROR;
    }
	static JSRuntime *runtime;
	if (!numQjsInterp-numFreeInterp) {
		runtime = JS_NewRuntime();
		getExoticObj(runtime);
	}
    qjs = js_mallocz_rt(runtime, sizeof(QjsInterp));
    qjs->rt = runtime;
    qjs->ctx = JS_NewContextRaw(qjs->rt);
    qjs->interp = interp;
	
	Tcl_InitHashTable(&qjs->objects, TCL_STRING_KEYS);

	JS_SetContextOpaque(qjs->ctx, (ContextOpaque*)qjs);
	
	JS_SetGlobalObject(qjs->ctx, findOrCreateObject(qjs, objv[1]), 1);
	interpTimeoutInit(qjs->ctx);
#if ALLOW_EVENTS
	eventInit(qjs->ctx);
#endif

    snprintf(zCmd, sizeof(zCmd), "::qjs::interp_%d", numQjsInterp++);
    Tcl_CreateObjCommand(interp, zCmd, interpCmd, qjs, delInterpCmd);
    Tcl_SetResult(interp, zCmd, TCL_VOLATILE);
    return TCL_OK;
}

static inline Tcl_Obj *atomToObj(JSContext *ctx, JSAtom atm) {
	size_t l;
	const char *s = JS_AtomToCStringLen(ctx, &l, atm);
	Tcl_Obj *p = Tcl_NewStringObj(s, l);
	JS_FreeCString(ctx, s);
	return p;
}

static JSValue 
QjsTcl_Get(JSContext *ctx, JSValue obj, JSAtom prop, JSValueConst rec)
{
    JSPropertyDescriptor desc;  // First, check if the property exists normally
	int rc = JS_GetOwnProperty(ctx, &desc, rec, prop);
	
	if (rc > 0) return desc.value;
	
	JSValue proto = JS_GetPrototype(ctx, rec);
	if (JS_IsObject(proto) && JS_HasProperty(ctx, proto, prop)) {
		return JS_GetProperty(ctx, proto, prop);
	}

	ContextOpaque *p = JS_GetContextOpaque(ctx);
	if (!p) return JS_ThrowTypeError(ctx, "Tcl interpreter not available");
	
	rc = callQjsTclMethod(p->interp, p->pLog, obj, atomToObj(ctx, prop), NULL);
	
	return objToValue(ctx, Tcl_GetObjResult(p->interp));
}

static int 
QjsTcl_Set(JSContext *ctx, JSValueConst obj, JSAtom prop, JSValueConst val, JSValueConst rec, int f)
{
    JSPropertyDescriptor desc;
    int nObj, rc = JS_GetOwnProperty(ctx, &desc, rec, prop);

    if (rc > 0 || JS_IsFunction(ctx, val)) {
        return JS_DefinePropertyValue(ctx, rec, prop, JS_DupValue(ctx, val), f);
    }
	
	JSValue proto = JS_GetPrototype(ctx, rec);
	if (JS_IsObject(proto) && JS_HasProperty(ctx, proto, prop)) {
		return JS_SetProperty(ctx, proto, prop, val);
	}
	
	ContextOpaque *p = JS_GetContextOpaque(ctx);
	if (!p) {
		JS_ThrowTypeError(ctx, "Tcl interpreter not available");
		return -1;
	}
	
	rc = callQjsTclMethod(p->interp, p->pLog, obj, atomToObj(ctx, prop), argValueToTcl((QjsInterp*)p, val, &nObj));
    removeTransientRefs((QjsInterp*)p, nObj);
	if (rc != TCL_OK) {
		throwTclError(ctx, p->interp);
		return -1;
	} if (!strcmp(Tcl_GetStringResult(p->interp), "NATIVE")) {
		return JS_DefinePropertyValue(ctx, rec, prop, JS_DupValue(ctx, val), f);
	}
    return 1;
}

static int QjsTcl_Has(JSContext *ctx, JSValueConst obj, JSAtom prop)
{
	JSValue val = QjsTcl_Get(ctx, obj, prop, obj);
	int has = !JS_IsUndefined(val);
	JS_FreeValue(ctx, val);
    return has;
}

static int 
QjsTcl_Enumerator(JSContext *ctx, JSPropertyEnum **pTab, uint32_t *pLen, JSValueConst obj)
{
    ContextOpaque *ctxOp = JS_GetContextOpaque(ctx);
    Tcl_Interp *interp = ctxOp->interp;

    Tcl_Obj *pRet;           /* Return value of script */
    Tcl_Obj **apRet;         /* List elements of pRet */
    int rc, nRet;            /* size of apString */
    JSPropertyEnum *pEnum;

    rc = callQjsTclMethod(interp, ctxOp->pLog, obj, Tcl_NewStringObj("Enumerator", -1), NULL);
    if (rc != TCL_OK) goto error;

    pRet = Tcl_GetObjResult(interp);
    rc = Tcl_ListObjGetElements(interp, pRet, &nRet, &apRet);
    if (rc != TCL_OK) goto error;

    pEnum = js_malloc(ctx, sizeof(pEnum[0]) * nRet);

    for (int i = 0; i < nRet; i++) {
        pEnum[i].atom = JS_NewAtom(ctx, Tcl_GetString(apRet[i]));
    }
	*pTab = pEnum;
	*pLen = nRet;

    return 0;
	error:
		js_free(ctx, pEnum);
		throwTclError(ctx, interp);
		return -1;
}

// Create the exotic methods structure
static JSClassExoticMethods tclExoticMethods = {
    .get_property = QjsTcl_Get,
    .set_property = QjsTcl_Set,
	.has_property = QjsTcl_Has,
	.get_own_property_names = QjsTcl_Enumerator,
};
static JSClassDef QjsTclClass = {
    "Object",
    .finalizer = finalizeObject,
	.exotic = &tclExoticMethods,  // Link to exotic methods
};

static JSValue 
tcl_call(JSContext *ctx, JSValueConst obj, JSValueConst this, int argc, JSValueConst *argv, int f)
{
	int rc, i, nObj = 0, nWI;
    QjsTclObject *p = JS_GetOpaque(obj, QjsTclCallClassId);
	QjsInterp *qjs = JS_GetContextOpaque(ctx);

    /* Make sure there is enough space to marshall the arguments */
	allocWordArray(qjs, p, argc+1);
	
	/* Set and reference-count "this" argument */
	if (JS_IsUndefined(this)) {
		interpGlobalSet(qjs, NULL, NULL);
		p->apWord[p->nWord] = Tcl_GetObjResult(qjs->interp);
	} else {
		JSClassID id = f & JS_CALL_FLAG_CONSTRUCTOR ? QjsTclCallClassId : QjsTclClassId;
		QjsTclObject *pTh = JS_GetOpaque(this, id);
		p->apWord[p->nWord] = pTh->pObj;
	}
	Tcl_IncrRefCount(p->apWord[p->nWord]);
	
	/* Convert arguments and increment reference counts in one loop */
    for (i = 0; i < argc; i++) {
		nWI = p->nWord + i + 1;
        p->apWord[nWI] = argValueToTcl(qjs, argv[i], &nObj);
        Tcl_IncrRefCount(p->apWord[nWI]);
    }
	rc = evalObjv(qjs->interp, p->nWord+argc+1, p->apWord);
	for (i = 0; i < argc; i++) {
        Tcl_DecrRefCount(p->apWord[p->nWord + i]);
    }
    removeTransientRefs(qjs, nObj);
	if (rc != TCL_OK) return throwTclError(ctx, qjs->interp);
	return objToValue(ctx, Tcl_GetObjResult(qjs->interp));
}

static JSClassDef QjsTclCallClass = {
    "Object",
    .finalizer = finalizeObject,
	.exotic = &tclExoticMethods,  // Link to exotic methods
	.call = tcl_call,
};
static void getExoticObj(JSRuntime *rt) {
    JS_NewClass(rt, QjsTclClassId, &QjsTclClass);
    JS_NewClass(rt, QjsTclCallClassId, &QjsTclCallClass);
}

/* Package initializer */
int Tclsee_Init(Tcl_Interp *interp) {
    /* Require stubs libraries version 8.4 or greater. */
#ifdef USE_TCL_STUBS
    if (Tcl_InitStubs(interp, "8.4", 0) == 0) {
        return TCL_ERROR;
    }
#endif
    JS_NewClassID(&QjsTclClassId);
    JS_NewClassID(&QjsTclCallClassId);
	
    Tcl_PkgProvide(interp, "Tclsee", "0.1");
    Tcl_CreateObjCommand(interp, "::qjs::interp", tclQjsInterp, NULL, NULL);
	Tcl_CreateObjCommand(interp, "::qjs::format", tclSeeFormat, NULL, NULL);
    // TODO: Add more commands (e.g., ::qjs::class, ::qjs::gc, etc.)
    return TCL_OK;
}
#if ALLOW_EVENTS
	#include "hv3events.c"
#endif